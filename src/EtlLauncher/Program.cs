using System.CommandLine;
using System.Data;
using System.Text.Json;
using Coding4Fun.Etl.Common;
using Gibraltar.DistributedLocking;
using Microsoft.Extensions.Logging;

namespace Coding4Fun.Etl.EtlLauncher;

public static class Program
{
    private static ILogger? _logger;
    private static ILogger Logger => _logger ?? (_logger = LoggerFactory.Create(builder =>
                builder.AddSimpleConsole(options =>
                {
                    options.IncludeScopes = true;
                    options.SingleLine = true;
                    options.TimestampFormat = "HH:mm:ss ";
                })).CreateLogger(typeof(Program).FullName!));

    public static async Task Main(string[] args)
    {
        Option<FileInfo> pipelineConfigOption = new("--pipeline-config")
        {
            Description = "The file with pipeline configuration, that was generated by Coding4Fun.Sql.Build task.",
            Required = true
        };

        Option<string> sourceConnectionStringOption = new("--source-connection-string")
        {
            Description = "The connection string to source database.",
            Required = true
        };

        Option<string> targetConnectionStringOption = new("--target-connection-string")
        {
            Description = "The connection string to target database.",
            Required = true
        };

        RootCommand rootCommand = new("Etl launcher that copying data from one database to another.");
        rootCommand.SetAction(async parseResult =>
        {
            FileInfo? pipelineConfig = parseResult.GetValue(pipelineConfigOption)
                ?? throw new ArgumentException("Pipeline config file is required.");

            string sourceConnectionString = parseResult.GetValue(sourceConnectionStringOption)
                ?? throw new ArgumentException("Source connection string is required.");

            string targetConnectionString = parseResult.GetValue(targetConnectionStringOption)
                ?? throw new ArgumentException("Target connection string is required.");

            if (!pipelineConfig.Exists) throw new ArgumentException("Pipeline config file doesn't exist.");

            await ExecuteEtlAsync(pipelineConfig, sourceConnectionString, targetConnectionString);
        });
        rootCommand.Options.Add(pipelineConfigOption);
        rootCommand.Options.Add(sourceConnectionStringOption);
        rootCommand.Options.Add(targetConnectionStringOption);

        ParseResult parsedArgs = rootCommand.Parse(args);

        await parsedArgs.InvokeAsync();
    }

    internal static async Task ExecuteEtlAsync(
        FileInfo pipelineConfigFile,
        string sourceConnectionString,
        string targetConnectionString)
    {
        string configJson = File.ReadAllText(pipelineConfigFile.FullName);
        PipelineConfiguration etlConfiguration = JsonSerializer.Deserialize<PipelineConfiguration>(configJson)!;

        DateTime? minRowId = null;
        DateTime? maxRowId = null;
        int copiedRowsCount = 1;

        ISourceDb sourceDb = new SqlServerSourceDb(sourceConnectionString);
        ITargetDb targetDb = new SqlServerTargetDb(targetConnectionString);
        DistributedLockManager lockManager = new(new SqlLockProvider(sourceConnectionString));

        // The following code must be executed only once at a time through the distributed nodes.
        using var distributedLock = lockManager.Lock(sourceDb, etlConfiguration.ProcedureName);
        for (int batchNumber = 1; 0 < copiedRowsCount; ++batchNumber)
        {
            Logger.LogInformation("Batch #{BatchNumber}", batchNumber);
            await targetDb.OpenConnectionAsync();

            foreach (TableDefinition tableDefinition in etlConfiguration.TableDefinitions.OrderByDescending(t => t.IsMain))
            {
                Logger.LogInformation("Creating {TempTableName}", tableDefinition.TempTableName);
                await targetDb.ExecuteAsync(tableDefinition.CreateTempTableStatement);

                if (tableDefinition.IsMain)
                {
                    Logger.LogInformation("Getting last offset");
                    DateTime lastOffset = await targetDb.GetLastOffsetAsync(etlConfiguration.ProcedureName) ?? DateTime.MinValue;

                    Logger.LogInformation("Bulk inserting into temp table");
                    await sourceDb.ExecuteReaderAsync(tableDefinition.SelectStatement, async dataReader =>
                    {
                        copiedRowsCount = await targetDb.BulkInsertAsync(tableDefinition.TempTableName, dataReader);
                    }, command =>
                    {
                        command.Parameters.Add("@Min", SqlDbType.DateTime2).Value = lastOffset;
                    });

                    Logger.LogInformation("Rows inserted: {CopiedRowsCount}", copiedRowsCount);

                    if (0 == copiedRowsCount) break;

                    Logger.LogInformation("Getting batch boundaries");
                    await targetDb.ExecuteReaderAsync(tableDefinition.SelectBatchSTatement, async reader =>
                    {
                        await Task.CompletedTask;
                        reader.Read();
                        minRowId = reader.GetDateTime(0);
                        maxRowId = reader.GetDateTime(1);
                    });
                }
                else
                {
                    Logger.LogInformation("Bulk inserting into temp table");
                    await sourceDb.ExecuteReaderAsync(tableDefinition.SelectStatement, async reader =>
                    {
                        await targetDb.BulkInsertAsync(tableDefinition.TempTableName, reader);
                    }, command =>
                    {
                        command.Parameters.Add("@Min", SqlDbType.DateTime2).Value = minRowId;
                        command.Parameters.Add("@Max", SqlDbType.DateTime2).Value = maxRowId;
                    });
                }
            }

            if (0 < copiedRowsCount)
            {
                Logger.LogInformation("Executing ETL");
                await targetDb.ExecuteAsync(etlConfiguration.EtlSql);
                await targetDb.SaveLastOffsetAsync(etlConfiguration.ProcedureName, maxRowId ?? throw new InvalidOperationException("Offset is null"));
            }
            Logger.LogInformation("Committing transaction");
            await targetDb.CloseConnectionAsync();
        }
    }
}